description: Пакетная система.

# Пакетная система

## Основа

Чтобы написать свой первый пакет, вам необходимо создать в классе объект `SimpleNetworkWrapper`. Я рекомендую сделать это в главном классе нашего мода. 

Создайте свой SimpleNetworkWrapper как статическое поле в выбраном классе, например:
```java
public static final SimpleNetworkWrapper network = NetworkRegistry.INSTANCE.newSimpleChannel("mymodid");
```
!!! tip "Подсказка"
    `mymodid` - это короткий идентификатор для вашего пакетного канала, обычно это просто идентификатор вашего мода. Он не должен быть слишком длинным.

## Создание пакетов
### IMessage:
Пакет определяется с помощью интерфейса `IMessage`. Этот интерфейс определяет 2 метода: `toBytes` и `fromBytes`. Эти методы, соответственно, записывают и считывают данные в вашем пакете в объект `ByteBuf` и из него.

`ByteBuf` является объектом, используемым для хранения потока (массива) байтов, отправляемых по сети.

Например, давайте определим небольшой пакет, который предназначен для отправки одного int по сети:
```java
public class MyMessage implements IMessage
{
    // Конструктор по умолчанию. Всегда требуется
    public MyMessage(){}

    int toSend;

    public MyMessage(int toSend)
    {
      this.toSend = toSend;
    }

    @Override public void toBytes(ByteBuf buf)
    {
      // Записывает int в buf
      buf.writeInt(toSend);
    }

    @Override public void fromBytes(ByteBuf buf)
    {
      // Читает int обратно из buf.
      // Обратите внимание: если у вас несколько значений,
      // вы должны читать их в том же порядке, в котором написали.
      toSend = buf.readInt();
    }
}
```
### IMessageHandler:
Теперь, как мы можем использовать этот пакет?

Сначала у нас должен быть класс, который может обрабатывать этот пакет. Он создается с помощью интерфейса IMessageHandler.

Допустим, мы хотим использовать это целое число, которое мы отправили, чтобы дать игроку столько-то алмазов на сервере. Сделаем этот обработчик:
```java
// Параметры IMessageHandler: <REQ, REPLY>
// Первый параметр - это пакет, который вы получаете, а второй - это пакет, который вы возвращаете.
// Возвращенный пакет можно использовать как "ответ" на отправленный пакет.
public class MyMessageHandler implements IMessageHandler<MyMessage, IMessage>
{
    // Обратите внимание, что требуется конструктор по умолчанию, но в этом случае он определяется неявно.

    @Override public IMessage onMessage(MyMessage message, MessageContext ctx)
    {
        // Игрок, от которого на сервер был отправлен пакет
        EntityPlayerMP serverPlayer = ctx.getServerHandler().player;

        // Значение, которое было отправлено
        int amount = message.toSend;

        // Выполнение действия в основном потоке сервера, добавив его как запланированную задачу
        serverPlayer.getServerWorld().addScheduledTask(() -> {
          serverPlayer.inventory.addItemStackToInventory(new ItemStack(Items.DIAMOND, amount));
        });

        // Если от пакета не последовал ответ
        return null;
    }
}
```
!!! info "Примечание"
    Рекомендуется (но не обязательно), интерфейс `IMessageHandler` добавлять в ваш класс пакета, а не создавать отдельный класс.

## Регистрация пакетов
Итак, теперь у нас есть пакет и обработчик для этого пакета. Но для работы SimpleNetworkWrapper нужна еще одна вещь!

Для использования пакета - пакет должен быть зарегистрирован с помощью дискриминатора, который представляет уникальный идентификатор для каждого канала для пакета. (Мы рекомендуем использовать статическую переменную для хранения идентификатора, а затем вызывать registerMessage с помощью id++. Это гарантирует 100% уникальность идентификаторов).

Для регистрации пакета, вызовите:
```java
YourClass.network.registerMessage(MyMessageHandler.class, MyMessage.class, 0, Side.SERVER);
```
!!! tip "Подсказка"
    `YourClass` - это класс в котором находиться наша статическая переменная с объектом SimpleNetworkWrapper

Это довольно сложный метод, поэтому как насчёт разобрать его:

- `messageHandler` - класс, обрабатывающий ваш пакет. Этот класс всегда должен иметь конструктор по умолчанию и должен иметь REQ с привязкой к типу, который соответствует следующему аргументу.
- `requestMessageType` - является фактическим классом пакета. Этот класс также должен иметь конструктор по умолчанию и соответствовать привязке типа REQ предыдущего параметра.
- `Side.SERVER` - это сторона, на которую будет получен ваш пакет (сервер/клиент). Если вы планируете отправить пакет в обе стороны, его необходимо зарегистрировать дважды, по одному на каждую сторону. (Дискриминаторы между сторонами могут быть одинаковыми, но это не обязательно)

## Важная информация!

Будьте осторожны при обработке пакетов на сервере. Клиент может попытаться воспользоваться обработкой пакетов, отправив неожиданные данные.

Распространенной проблемой является уязвимость к генерации произвольных блоков. Обычно это происходит, когда сервер доверяет позиции блока, отправленной клиентом для доступа к блокам и объектам плитки. При доступе к блокам и Tile Entitiies в незагруженных областях мира сервер либо создаст, либо загрузит эту область с диска, а затем быстро запишет ее на диск. Это может быть использовано для нанесения катастрофического ущерба производительности сервера и объему хранилища.

Чтобы избежать этой проблемы, общее практическое правило - обращаться к блокам и объектам тайлов только в том случае, если world.blockExists(x, y, z) истинно.

## Использование пакетов
При отправке пакетов убедитесь, что на принимающей стороне зарегистрирован обработчик указанного пакета. Иначе - пакет будет отправлен по сети, а затем выброшен, что приведет к "утечке" пакета (Это безвредно, за исключением ненужного использования сети).

### Отправка на сервер
Есть только один способ отправить пакет на сервер. Это потому, что существует только один сервер и, конечно же, только один способ отправки на этот сервер. Для этого нам снова нужен SimpleNetworkWrapper, который был определен ранее. Нужно просто вызвать:
```java
YourClass.network.sendToServer(new MyMessage(*значение для отправки*))
```

### Отправка на клиент

- **sendToAll** - вызов `network.sendToAll`, который отправит пакет один раз каждому игроку на сервере, независимо от того, в каком месте или измерении они находятся.
- **sendToDimension** - вызов `network.sendToDimension`, который принимает два аргумента: `IMessage` и `integer`. `Integer` - это идентификатор измерения для отправки, который можно получить с помощью `world.provider.dimensionId`. Пакет будет отправлен всем игрокам, находящимся в измерении, чей идентификатор был указан.
- **sendTo** - вызов `network.sendTo`, который служит для отправки пакетов одному клиенту. Для этого требуются `IMessage` и `EntityPlayerMP` для отправки пакета. Обратите внимание, что, хотя это не более универсальный `EntityPlayer`, пока вы находитесь на сервере, вы можете безопасно использовать любой `EntityPlayer` в `EntityPlayerMP`.
- **sendToAllAround** - вызов `network.sendToAllAround`, который принимает два аргумента: `IMessage` и `NetworkRegistry.TargetPoint`. Данный метод отправляет пакеты всем игрокам на сервере, в определенном радиусе от заданой точки. Смотреть объект `TargetPoint`

#### На этом конец!
!!! info "Примечание"
    Данный раздел был [перенесен](https://forum.mcmodding.ru/resources/simpleimpl-paketnaja-sistema.250/) с раздела ***туториал*** на форуме и отформатирован для большей удобности новичков


